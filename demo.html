<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TagsInput.js — Demo</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Syne:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0d0d0d;
    --surface: #161616;
    --border: #2a2a2a;
    --accent: #e8ff47;
    --accent2: #47c8ff;
    --accent3: #ff6b6b;
    --text: #f0f0f0;
    --muted: #666;
    --radius: 6px;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'IBM Plex Mono', monospace;
    min-height: 100vh;
    padding: 60px 24px;
  }

  header {
    max-width: 820px;
    margin: 0 auto 64px;
  }

  header h1 {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: clamp(2.4rem, 5vw, 4rem);
    line-height: 1;
    letter-spacing: -0.02em;
  }

  header h1 span { color: var(--accent); }

  header p {
    margin-top: 14px;
    color: var(--muted);
    font-size: 0.85rem;
    line-height: 1.7;
    max-width: 500px;
  }

  .demo-grid {
    max-width: 820px;
    margin: 0 auto;
    display: flex;
    flex-direction: column;
    gap: 48px;
  }

  .demo-block {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 32px;
  }

  .demo-block h2 {
    font-family: 'Syne', sans-serif;
    font-size: 1rem;
    font-weight: 700;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 6px;
  }

  .demo-block p.desc {
    font-size: 0.78rem;
    color: var(--muted);
    margin-bottom: 20px;
    line-height: 1.6;
  }

  .output {
    margin-top: 16px;
    font-size: 0.75rem;
    color: var(--muted);
    background: #0d0d0d;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 10px 14px;
    min-height: 36px;
  }

  .output strong { color: var(--accent2); }

  .actions {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 12px;
  }

  button {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.72rem;
    padding: 6px 14px;
    border-radius: var(--radius);
    border: 1px solid var(--border);
    background: transparent;
    color: var(--text);
    cursor: pointer;
    transition: all 0.15s;
  }

  button:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  button.danger:hover {
    border-color: var(--accent3);
    color: var(--accent3);
  }

  /* ============================
     TAGSINPUT CORE STYLES
  ============================ */

  .tags-input-wrapper {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 6px;
    padding: 8px 10px;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    background: var(--bg);
    cursor: text;
    transition: border-color 0.2s;
    min-height: 46px;
  }

  .tags-input-wrapper:focus-within {
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(232,255,71,0.08);
  }

  .tags-input-wrapper.tags-invalid {
    border-color: var(--accent3);
    box-shadow: 0 0 0 3px rgba(255,107,107,0.08);
    animation: shake 0.3s ease;
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
  }

  .tag-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 3px 10px;
    border-radius: 4px;
    background: rgba(232,255,71,0.12);
    border: 1px solid rgba(232,255,71,0.3);
    color: var(--accent);
    font-size: 0.78rem;
    font-family: 'IBM Plex Mono', monospace;
    animation: tagIn 0.15s ease;
    cursor: default;
  }

  @keyframes tagIn {
    from { opacity: 0; transform: scale(0.85); }
    to   { opacity: 1; transform: scale(1); }
  }

  .tag-item.removing {
    animation: tagOut 0.15s ease forwards;
  }

  @keyframes tagOut {
    to { opacity: 0; transform: scale(0.7); }
  }

  .tag-remove {
    background: none;
    border: none;
    color: inherit;
    opacity: 0.5;
    cursor: pointer;
    padding: 0;
    font-size: 0.9rem;
    line-height: 1;
    transition: opacity 0.1s;
    display: flex;
    align-items: center;
  }

  .tag-remove:hover {
    opacity: 1;
    color: var(--accent3);
    border: none;
  }

  .tags-real-input {
    border: none;
    outline: none;
    background: transparent;
    color: var(--text);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.82rem;
    flex: 1;
    min-width: 120px;
    padding: 2px 4px;
    caret-color: var(--accent);
  }

  .tags-real-input::placeholder { color: var(--muted); }

  /* Theme variants */
  .tags-input-wrapper.theme-blue .tag-item {
    background: rgba(71,200,255,0.1);
    border-color: rgba(71,200,255,0.3);
    color: var(--accent2);
  }
  .tags-input-wrapper.theme-blue:focus-within {
    border-color: var(--accent2);
    box-shadow: 0 0 0 3px rgba(71,200,255,0.08);
  }

  .tags-input-wrapper.theme-red .tag-item {
    background: rgba(255,107,107,0.1);
    border-color: rgba(255,107,107,0.3);
    color: var(--accent3);
  }
  .tags-input-wrapper.theme-red:focus-within {
    border-color: var(--accent3);
    box-shadow: 0 0 0 3px rgba(255,107,107,0.08);
  }

  /* Suggestions dropdown */
  .tags-suggestions {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    right: 0;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    overflow: hidden;
    z-index: 100;
    box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  }

  .tags-suggestion-item {
    padding: 8px 14px;
    font-size: 0.8rem;
    cursor: pointer;
    transition: background 0.1s;
  }

  .tags-suggestion-item:hover,
  .tags-suggestion-item.active {
    background: rgba(232,255,71,0.08);
    color: var(--accent);
  }

  .tags-suggestion-item mark {
    background: none;
    color: var(--accent);
    font-weight: 600;
  }

  .tags-wrapper-rel { position: relative; }

  hr.api-divider {
    border: none;
    border-top: 1px solid var(--border);
    margin: 40px 0;
  }

  .api-section { max-width: 820px; margin: 0 auto 80px; }

  .api-section h2 {
    font-family: 'Syne', sans-serif;
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 24px;
  }

  .api-section h2 span { color: var(--accent); }

  .method-list {
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  .method-item {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 14px 18px;
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 8px;
    align-items: start;
  }

  .method-item code {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.8rem;
    color: var(--accent);
  }

  .method-item p {
    font-size: 0.75rem;
    color: var(--muted);
    line-height: 1.5;
    margin-top: 3px;
    grid-column: 1 / -1;
  }

  .badge {
    font-size: 0.65rem;
    padding: 2px 8px;
    border-radius: 20px;
    border: 1px solid var(--border);
    color: var(--muted);
    white-space: nowrap;
  }
</style>
</head>
<body>

<header>
  <h1>Tags<span>Input</span>.js</h1>
  <p>Plugin vanilla JS pour la gestion de champs tags — sans dépendance, entièrement configurable, avec validation personnalisée et API complète.</p>
</header>

<div class="demo-grid">

  <!-- Démo 1 : basique -->
  <div class="demo-block">
    <h2>Basique</h2>
    <p class="desc">Séparateur virgule ou Entrée. Backspace supprime le dernier tag. Pas de doublons.</p>
    <div class="tags-wrapper-rel">
      <input type="text" id="basic" placeholder="Ajouter un tag…">
    </div>
    <div class="output" id="basic-out"><strong>tags:</strong> []</div>
    <div class="actions">
      <button onclick="basicInstance.add('javascript')">+ "javascript"</button>
      <button onclick="basicInstance.add('css')">+ "css"</button>
      <button onclick="basicInstance.remove('css')" class="danger">- "css"</button>
      <button onclick="basicInstance.clear()" class="danger">Clear all</button>
      <button onclick="updateOut('basic-out', basicInstance.getTags())">getTags()</button>
    </div>
  </div>

  <!-- Démo 2 : validation personnalisée -->
  <div class="demo-block">
    <h2>Validation personnalisée</h2>
    <p class="desc">Tags emails uniquement. Min 3 chars, max 60. Interdit les doublons case-insensitive. Secoue le champ si invalide.</p>
    <div class="tags-wrapper-rel">
      <input type="text" id="validated" placeholder="email@exemple.com">
    </div>
    <div class="output" id="validated-out"><strong>tags:</strong> []</div>
  </div>

  <!-- Démo 3 : suggestions -->
  <div class="demo-block">
    <h2>Autocomplete / Suggestions</h2>
    <p class="desc">Liste de suggestions filtrée à la saisie. Navigation clavier (↑↓ + Entrée).</p>
    <div class="tags-wrapper-rel">
      <input type="text" id="suggest" placeholder="Commencez à taper…">
    </div>
    <div class="output" id="suggest-out"><strong>tags:</strong> []</div>
  </div>

  <!-- Démo 4 : max tags + thème bleu -->
  <div class="demo-block">
    <h2>Max tags + thème</h2>
    <p class="desc">Limité à 4 tags. Le champ se verrouille au maximum. Thème "blue".</p>
    <div class="tags-wrapper-rel">
      <input type="text" id="limited" placeholder="Max 4 tags…">
    </div>
    <div class="output" id="limited-out"><strong>tags:</strong> []</div>
    <div class="actions">
      <button onclick="limitedInstance.fill(['alpha','beta','gamma','delta'])">fill(['alpha','beta','gamma','delta'])</button>
      <button onclick="limitedInstance.clear()" class="danger">Clear</button>
    </div>
  </div>

  <!-- Démo 5 : readonly & toggle -->
  <div class="demo-block">
    <h2>Readonly / Disabled / Replace</h2>
    <p class="desc">Contrôle d'état et remplacement programmatique.</p>
    <div class="tags-wrapper-rel">
      <input type="text" id="state" placeholder="Tags…">
    </div>
    <div class="output" id="state-out"><strong>tags:</strong> []</div>
    <div class="actions">
      <button onclick="stateInstance.setReadonly(true)">setReadonly(true)</button>
      <button onclick="stateInstance.setReadonly(false)">setReadonly(false)</button>
      <button onclick="stateInstance.setDisabled(true)" class="danger">setDisabled(true)</button>
      <button onclick="stateInstance.setDisabled(false)">setDisabled(false)</button>
      <button onclick="stateInstance.replace(['foo','bar','baz'])">replace(['foo','bar','baz'])</button>
      <button onclick="updateOut('state-out', stateInstance.getTags())">getTags()</button>
      <button onclick="updateOut('state-out', stateInstance.count()+' tags')">count()</button>
    </div>
  </div>

</div>

<hr class="api-divider" style="max-width:820px;margin:60px auto 40px;">

<div class="api-section">
  <h2>API <span>Reference</span></h2>
  <div class="method-list">
    <div class="method-item"><code>add(value)</code><span class="badge">→ boolean</span><p>Ajoute un tag. Retourne true si ajouté, false si rejeté (validation / doublon / max).</p></div>
    <div class="method-item"><code>remove(value)</code><span class="badge">→ boolean</span><p>Supprime un tag par valeur exacte.</p></div>
    <div class="method-item"><code>removeAt(index)</code><span class="badge">→ boolean</span><p>Supprime un tag par index (0-based).</p></div>
    <div class="method-item"><code>getTags()</code><span class="badge">→ string[]</span><p>Retourne une copie du tableau de tags.</p></div>
    <div class="method-item"><code>fill(array)</code><span class="badge">→ void</span><p>Remplace tous les tags par ceux du tableau (validation appliquée).</p></div>
    <div class="method-item"><code>replace(array)</code><span class="badge">→ void</span><p>Alias de fill(). Vide d'abord, puis injecte.</p></div>
    <div class="method-item"><code>clear()</code><span class="badge">→ void</span><p>Supprime tous les tags.</p></div>
    <div class="method-item"><code>has(value)</code><span class="badge">→ boolean</span><p>Teste si un tag est présent.</p></div>
    <div class="method-item"><code>count()</code><span class="badge">→ number</span><p>Nombre de tags actuels.</p></div>
    <div class="method-item"><code>setReadonly(bool)</code><span class="badge">→ void</span><p>Passe en mode lecture seule (affichage des tags, pas de saisie, pas de suppression).</p></div>
    <div class="method-item"><code>setDisabled(bool)</code><span class="badge">→ void</span><p>Désactive complètement le champ (opacité réduite).</p></div>
    <div class="method-item"><code>focus()</code><span class="badge">→ void</span><p>Met le focus sur l'input interne.</p></div>
    <div class="method-item"><code>reset()</code><span class="badge">→ void</span><p>Remet l'instance à son état initial (tags initiaux).</p></div>
    <div class="method-item"><code>on(event, fn)</code><span class="badge">→ void</span><p>Écoute un événement : <em>add</em>, <em>remove</em>, <em>invalid</em>, <em>max</em>, <em>clear</em>, <em>change</em>.</p></div>
    <div class="method-item"><code>off(event, fn)</code><span class="badge">→ void</span><p>Désabonne un handler.</p></div>
    <div class="method-item"><code>destroy()</code><span class="badge">→ void</span><p>Détruit l'instance et restaure l'input original.</p></div>
  </div>
</div>

<script>
/* ============================================================
   TagsInput.js — v1.0.0
   Vanilla JS, zero dependencies
   ============================================================ */

class TagsInput {
  /**
   * @param {HTMLInputElement|string} el  - Input cible ou sélecteur CSS
   * @param {Object} options
   * @param {string[]}  [options.initialTags=[]]        - Tags initiaux
   * @param {string[]}  [options.separators=[',']]       - Caractères déclencheurs (en plus de Enter)
   * @param {number}    [options.maxTags=Infinity]       - Nombre max de tags
   * @param {number}    [options.minLength=1]            - Longueur minimale d'un tag
   * @param {number}    [options.maxLength=Infinity]     - Longueur maximale d'un tag
   * @param {boolean}   [options.allowDuplicates=false]  - Autoriser les doublons
   * @param {boolean}   [options.caseSensitive=true]     - Comparaison sensible à la casse
   * @param {Function}  [options.validate]               - fn(value) → true|false|string (message)
   * @param {Function}  [options.transform]              - fn(value) → string  (ex: trim, lowercase)
   * @param {string[]}  [options.suggestions=[]]         - Liste pour l'autocomplete
   * @param {number}    [options.suggestionsLimit=6]     - Nombre max de suggestions affichées
   * @param {string}    [options.theme='']               - 'blue' | 'red' | ''
   * @param {string}    [options.placeholder='']         - Placeholder de l'input interne
   * @param {boolean}   [options.readonly=false]
   * @param {boolean}   [options.disabled=false]
   */
  constructor(el, options = {}) {
    this._el = typeof el === 'string' ? document.querySelector(el) : el;
    if (!this._el) throw new Error('TagsInput: element not found');

    this._opts = Object.assign({
      initialTags: [],
      separators: [','],
      maxTags: Infinity,
      minLength: 1,
      maxLength: Infinity,
      allowDuplicates: false,
      caseSensitive: true,
      validate: null,
      transform: v => v.trim(),
      suggestions: [],
      suggestionsLimit: 6,
      theme: '',
      placeholder: this._el.placeholder || '',
      readonly: false,
      disabled: false,
    }, options);

    this._tags = [];
    this._initialTags = [...this._opts.initialTags];
    this._listeners = {};
    this._suggestionIndex = -1;

    this._build();
    this._opts.initialTags.forEach(t => this.add(t));
    if (this._opts.readonly) this.setReadonly(true);
    if (this._opts.disabled) this.setDisabled(true);
  }

  /* ── Build DOM ─────────────────────────────────────────── */

  _build() {
    // Wrapper
    this._wrapper = document.createElement('div');
    this._wrapper.className = 'tags-input-wrapper' + (this._opts.theme ? ' theme-' + this._opts.theme : '');

    // Input interne
    this._input = document.createElement('input');
    this._input.type = 'text';
    this._input.className = 'tags-real-input';
    this._input.placeholder = this._opts.placeholder;
    this._input.autocomplete = 'off';
    this._input.spellcheck = false;

    this._wrapper.appendChild(this._input);

    // Injecter dans le DOM à la place de l'élément original
    this._el.parentNode.insertBefore(this._wrapper, this._el);
    this._el.style.display = 'none';
    this._wrapper.appendChild(this._el); // conserver l'input original (form submit)
    this._el.name = this._el.name || '';

    // Suggestions container
    if (this._opts.suggestions.length) {
      this._suggBox = document.createElement('div');
      this._suggBox.className = 'tags-suggestions';
      this._suggBox.style.display = 'none';
      this._wrapper.parentNode.appendChild(this._suggBox);
    }

    this._bindEvents();
  }

  _bindEvents() {
    // Clic sur le wrapper → focus input
    this._wrapper.addEventListener('click', e => {
      if (!e.target.classList.contains('tag-remove')) this._input.focus();
    });

    // Saisie clavier
    this._input.addEventListener('keydown', e => this._onKeydown(e));
    this._input.addEventListener('input', () => this._onInput());
    this._input.addEventListener('blur', () => {
      setTimeout(() => this._hideSuggestions(), 150);
    });
  }

  _onKeydown(e) {
    const val = this._input.value;

    // Séparateurs personnalisés
    if (this._opts.separators.includes(e.key)) {
      e.preventDefault();
      this.add(val);
      this._input.value = '';
      this._hideSuggestions();
      return;
    }

    switch (e.key) {
      case 'Enter':
        e.preventDefault();
        if (this._suggestionIndex >= 0 && this._suggBox && this._visibleSuggestions) {
          this.add(this._visibleSuggestions[this._suggestionIndex]);
        } else {
          this.add(val);
        }
        this._input.value = '';
        this._hideSuggestions();
        break;

      case 'Backspace':
        if (!val && this._tags.length) {
          this.removeAt(this._tags.length - 1);
        }
        break;

      case 'Escape':
        this._hideSuggestions();
        break;

      case 'ArrowDown':
        e.preventDefault();
        this._moveSuggestion(1);
        break;

      case 'ArrowUp':
        e.preventDefault();
        this._moveSuggestion(-1);
        break;
    }
  }

  _onInput() {
    const val = this._input.value;
    // Auto-split sur séparateurs tapés en milieu de texte
    for (const sep of this._opts.separators) {
      if (val.includes(sep)) {
        const parts = val.split(sep);
        parts.slice(0, -1).forEach(p => this.add(p));
        this._input.value = parts[parts.length - 1];
        return;
      }
    }
    this._showSuggestions(val);
  }

  /* ── Suggestions ────────────────────────────────────────── */

  _showSuggestions(query) {
    if (!this._suggBox || !query) { this._hideSuggestions(); return; }

    const q = query.toLowerCase();
    const matches = this._opts.suggestions
      .filter(s => s.toLowerCase().includes(q) && !this._tags.includes(s))
      .slice(0, this._opts.suggestionsLimit);

    if (!matches.length) { this._hideSuggestions(); return; }

    this._visibleSuggestions = matches;
    this._suggestionIndex = -1;
    this._suggBox.innerHTML = '';

    matches.forEach((m, i) => {
      const item = document.createElement('div');
      item.className = 'tags-suggestion-item';
      // Highlight match
      const idx = m.toLowerCase().indexOf(q);
      item.innerHTML = m.slice(0, idx) + '<mark>' + m.slice(idx, idx + q.length) + '</mark>' + m.slice(idx + q.length);
      item.addEventListener('mousedown', () => {
        this.add(m);
        this._input.value = '';
        this._hideSuggestions();
      });
      this._suggBox.appendChild(item);
    });

    this._suggBox.style.display = 'block';
  }

  _hideSuggestions() {
    if (this._suggBox) {
      this._suggBox.style.display = 'none';
      this._suggestionIndex = -1;
    }
  }

  _moveSuggestion(dir) {
    if (!this._suggBox || this._suggBox.style.display === 'none') return;
    const items = this._suggBox.querySelectorAll('.tags-suggestion-item');
    if (!items.length) return;

    items[this._suggestionIndex]?.classList.remove('active');
    this._suggestionIndex = Math.max(-1, Math.min(items.length - 1, this._suggestionIndex + dir));
    items[this._suggestionIndex]?.classList.add('active');
  }

  /* ── Validation interne ─────────────────────────────────── */

  _normalize(value) {
    let v = this._opts.transform ? this._opts.transform(value) : value;
    return v;
  }

  _isDuplicate(value) {
    if (this._opts.allowDuplicates) return false;
    const cmp = this._opts.caseSensitive ? v => v : v => v.toLowerCase();
    return this._tags.some(t => cmp(t) === cmp(value));
  }

  _validate(value) {
    if (value.length < this._opts.minLength) return false;
    if (value.length > this._opts.maxLength) return false;
    if (this._isDuplicate(value)) return false;
    if (this._opts.validate) {
      const result = this._opts.validate(value);
      if (result === false || typeof result === 'string') return false;
    }
    return true;
  }

  _shake() {
    this._wrapper.classList.add('tags-invalid');
    setTimeout(() => this._wrapper.classList.remove('tags-invalid'), 400);
  }

  /* ── API publique ───────────────────────────────────────── */

  /**
   * Ajoute un tag.
   * @returns {boolean} true si ajouté.
   */
  add(value) {
    if (this._opts.readonly || this._opts.disabled) return false;

    const v = this._normalize(value);
    if (!v) return false;

    if (this._tags.length >= this._opts.maxTags) {
      this._shake();
      this._emit('max', { value: v, tags: this.getTags() });
      return false;
    }

    if (!this._validate(v)) {
      this._shake();
      this._emit('invalid', { value: v, tags: this.getTags() });
      return false;
    }

    this._tags.push(v);
    this._renderTag(v);
    this._syncHidden();
    this._emit('add', { value: v, tags: this.getTags() });
    this._emit('change', { tags: this.getTags() });
    return true;
  }

  /**
   * Supprime un tag par valeur.
   * @returns {boolean}
   */
  remove(value) {
    const idx = this._tags.indexOf(value);
    if (idx === -1) return false;
    return this.removeAt(idx);
  }

  /**
   * Supprime un tag par index.
   * @returns {boolean}
   */
  removeAt(index) {
    if (this._opts.readonly || this._opts.disabled) return false;
    if (index < 0 || index >= this._tags.length) return false;

    const value = this._tags[index];
    this._tags.splice(index, 1);

    const tagEls = this._wrapper.querySelectorAll('.tag-item');
    if (tagEls[index]) {
      tagEls[index].classList.add('removing');
      setTimeout(() => tagEls[index].remove(), 150);
    }

    this._syncHidden();
    this._emit('remove', { value, tags: this.getTags() });
    this._emit('change', { tags: this.getTags() });
    return true;
  }

  /** Retourne une copie du tableau de tags. */
  getTags() { return [...this._tags]; }

  /** Teste si un tag est présent. */
  has(value) { return this._tags.includes(value); }

  /** Retourne le nombre de tags. */
  count() { return this._tags.length; }

  /** Vide et remplace par un nouveau tableau. */
  fill(arr) {
    this.clear();
    arr.forEach(v => this.add(v));
  }

  /** Alias de fill(). */
  replace(arr) { this.fill(arr); }

  /** Supprime tous les tags. */
  clear() {
    this._tags = [];
    this._wrapper.querySelectorAll('.tag-item').forEach(el => el.remove());
    this._syncHidden();
    this._emit('clear', { tags: [] });
    this._emit('change', { tags: [] });
  }

  /** Remet l'instance à son état initial. */
  reset() { this.fill(this._initialTags); }

  /** Focus sur l'input. */
  focus() { this._input.focus(); }

  /** Mode lecture seule. */
  setReadonly(bool) {
    this._opts.readonly = bool;
    this._input.style.display = bool ? 'none' : '';
    this._wrapper.querySelectorAll('.tag-remove').forEach(b => b.style.display = bool ? 'none' : '');
  }

  /** Désactive le champ. */
  setDisabled(bool) {
    this._opts.disabled = bool;
    this._wrapper.style.opacity = bool ? '0.45' : '';
    this._wrapper.style.pointerEvents = bool ? 'none' : '';
  }

  /** Écoute un événement : add | remove | invalid | max | clear | change */
  on(event, fn) {
    if (!this._listeners[event]) this._listeners[event] = [];
    this._listeners[event].push(fn);
  }

  /** Désabonne un handler. */
  off(event, fn) {
    if (!this._listeners[event]) return;
    this._listeners[event] = this._listeners[event].filter(f => f !== fn);
  }

  /** Détruit l'instance et restaure l'input original. */
  destroy() {
    this._el.style.display = '';
    this._wrapper.parentNode.insertBefore(this._el, this._wrapper);
    this._wrapper.remove();
    if (this._suggBox) this._suggBox.remove();
  }

  /* ── Interne ────────────────────────────────────────────── */

  _renderTag(value) {
    const tag = document.createElement('span');
    tag.className = 'tag-item';
    tag.textContent = value;

    const btn = document.createElement('button');
    btn.className = 'tag-remove';
    btn.innerHTML = '×';
    btn.title = 'Supprimer';
    btn.addEventListener('click', e => {
      e.stopPropagation();
      this.remove(value);
    });

    tag.appendChild(btn);
    this._wrapper.insertBefore(tag, this._input);
  }

  _syncHidden() {
    this._el.value = this._tags.join(',');
  }

  _emit(event, data) {
    (this._listeners[event] || []).forEach(fn => fn(data));
  }
}


/* ============================================================
   DÉMOS
============================================================ */

function updateOut(id, val) {
  const el = document.getElementById(id);
  const str = Array.isArray(val) ? JSON.stringify(val) : val;
  el.innerHTML = '<strong>result:</strong> ' + str;
}

// --- Basique ---
const basicInstance = new TagsInput('#basic', {
  initialTags: ['html', 'css'],
  placeholder: 'Ajouter un tag…',
});
basicInstance.on('change', ({ tags }) => {
  document.getElementById('basic-out').innerHTML = '<strong>tags:</strong> ' + JSON.stringify(tags);
});

// --- Validation email ---
const validatedInstance = new TagsInput('#validated', {
  placeholder: 'email@exemple.com',
  minLength: 5,
  maxLength: 60,
  caseSensitive: false,
  allowDuplicates: false,
  validate(value) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value);
  },
  transform(v) { return v.trim().toLowerCase(); },
});
validatedInstance.on('change', ({ tags }) => {
  document.getElementById('validated-out').innerHTML = '<strong>tags:</strong> ' + JSON.stringify(tags);
});
validatedInstance.on('invalid', ({ value }) => {
  document.getElementById('validated-out').innerHTML = '<strong style="color:#ff6b6b">invalide:</strong> "' + value + '" n\'est pas un email valide';
});

// --- Suggestions ---
const suggestInstance = new TagsInput('#suggest', {
  placeholder: 'Langage, framework…',
  suggestions: [
    'JavaScript','TypeScript','Python','Rust','Go','Java','PHP','Ruby','Swift','Kotlin',
    'React','Vue','Angular','Svelte','Next.js','Nuxt','Django','Laravel','Spring','Rails',
    'CSS','Sass','Tailwind','GraphQL','REST','Docker','Kubernetes',
  ],
  suggestionsLimit: 6,
});
suggestInstance.on('change', ({ tags }) => {
  document.getElementById('suggest-out').innerHTML = '<strong>tags:</strong> ' + JSON.stringify(tags);
});

// --- Limited / thème ---
const limitedInstance = new TagsInput('#limited', {
  placeholder: 'Max 4 tags…',
  maxTags: 4,
  theme: 'blue',
});
limitedInstance.on('change', ({ tags }) => {
  document.getElementById('limited-out').innerHTML = '<strong>tags:</strong> ' + JSON.stringify(tags);
});
limitedInstance.on('max', () => {
  document.getElementById('limited-out').innerHTML = '<strong style="color:#ff6b6b">max atteint</strong> (4 tags maximum)';
});

// --- State control ---
const stateInstance = new TagsInput('#state', {
  initialTags: ['exemple'],
  theme: 'red',
});
stateInstance.on('change', ({ tags }) => {
  document.getElementById('state-out').innerHTML = '<strong>tags:</strong> ' + JSON.stringify(tags);
});
</script>
</body>
</html>
